---
layout: narrative
title: "Meshing"
author: Marin Lauber, Vanessa Nehruji
rights: Public Domain
publication-date: 2019
toc:
- Title Page
- Introduction
- Dolfin Meshing Tools
- 2D mshr
- 3D mshr
- Appendix

---

<a id="title-page" />

<p class="centered larger">MESHING TOOLS</p>

---
* ToC
{:toc}

---

## INTRODUCTION




---

## DOLFIN MESHING TOOLS
FEniCS has a few basic functions in the dolfin package to create quick basic meshes such as a unit square or unit disk. The <a href="https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.generation.html">latest documentation</a> is quite sparse

---

## 2D MSHR
<a href="https://bitbucket.org/fenics-project/mshr">mshr</a> is a package developed for FEniCS to generate complex meshes using the Constructive Solid Geometry (CSG) technique. CSG creates complex geometry from simple primitive objects through the boolean operators, union, difference and intersection, as well as the basic transformations, scaling, rotation and translation.

### Primitives

In 2D, mshr has four primitive shapes:
+ <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/Rectangle">Rectangle</a>
+ <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/Circle">Circle</a>
+ <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/Ellipse">Ellipse</a>
+ <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/Polygon">Polygon</a>

These shapes can be defined using dolfin.Point(x, y, z):
```python
import dolfin
from mshr import *

rect = Rectangle(dolfin.Point(0., 0.), dolfin.Point(1., 1.))
circ = Circle(dolfin.Point(0., 0.), 0.5)
ellipse = Ellipse(dolfin.Point(0., 0.), 0.8, 0.5)

domain_vertices = [dolfin.Point(0.0, 0.0),
                   dolfin.Point(10.0, 0.0),
                   dolfin.Point(10.0, 5.0),
                   dolfin.Point(8.0, 10.0),
                   dolfin.Point(7.5, 1.0),
                   dolfin.Point(4.5, 1.0),
                   dolfin.Point(2.0, 4.0),
                   dolfin.Point(0.0, 4.0),
                   dolfin.Point(0.0, 0.0)]
polygon = Polygon(domain_vertices)
```

These all produce a mshr::CSGPrimitive2D object which can be used to generate the mesh with the function <a href="https://github.com/FEniCS/mshr/blob/master/src/MeshGenerator.cpp">generate_mesh(CSGGeometry, resolution)</a>.
```python
rect_mesh = generate_mesh(rect, 10)
circle_mesh = generate_mesh(circ, 10)
ellipse_mesh = generate_mesh(ellipse, 10)
polygon_mesh = generate_mesh(polygon, 10)
```

This creates a dolfin::Mesh object which can be plotted with dolfin.plot(mesh)

```python
pyplot.figure()

pyplot.subplot(1, 4, 1)
pyplot.title("Rectangle Mesh")
dolfin.plot(rect_mesh)

pyplot.subplot(1, 4, 2)
pyplot.title("Circle Mesh")
dolfin.plot(circ_mesh)

pyplot.subplot(1, 4, 3)
pyplot.title("Ellipse Mesh")
dolfin.plot(ellipse_mesh)
pyplot.xlim(-1,1)
pyplot.ylim(-1,1)

pyplot.subplot(1, 4, 4)
pyplot.title("Polygon Mesh")
dolfin.plot(polygon_mesh)

pyplot.tight_layout();
```
![mshr2Dprimitives](../../assets/img/mshr2Dprimitives.png){: .center-image }

---

### Operations
As mentioned before, there are two types of operators:
+ Boolean Operators:
  * <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/CSGDifference">Difference</a>
  * <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/CSGUnion">Union</a>
  * <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/CSGIntersection">Intersection</a>
+ Geometric Transformations:
  * <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/CSGScaling">Scaling</a>
  * <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/CSGRotation">Rotation</a>
  * <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/CSGTranslation">Translation</a>

#### Boolean

We will demonstrate boolean operators between a circle at $$(0, 0)$$ with radius, $$r = 0.5$$, and a rectangle from $$(0, 0)$$ to $$(1, 1)$$.

![mesh2Dbool_prim](../../assets/img/mshr2Dbool_prim.png){: .center-image }

In mshr, the simple operators $$(-,+,*)$$ are overloaded for boolean operations (<a href="https://bitbucket.org/fenics-project/mshr/wiki/API/CSGDifference">difference</a>, <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/CSGUnion">union</a>, <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/CSGIntersection">intersection</a>). This creates mshr::CSGPrimitive2d object from which a mesh can be generated.
```python
## Apply Boolean Operations
diff_domain = rect - circ
union_domain = rect + circ
intersect_domain = rect * circ

## Generate dolfin::Mesh
diff_mesh = generate_mesh(diff_domain, 10)
union_mesh = generate_mesh(union_domain, 10)
intersect_mesh = generate_mesh(intersect_domain, 10)
```

![mesh2Dboolean](../../assets/img/mshr2Dboolean.png){: .center-image }

---

#### Geometric Transformations

We will show geometric transformaions (scaling, rotation, translation) on a rectangle from $$(0, 0)$$ to $$(1, 1)$$. The $$*$$ operator has been overloaded to allow for scaling by a float but other transformations require the full function.

![mesh2Dgeom_prim](../../assets/img/mshr2Dgeom_prim.png){: .center-image }

```python
## Apply Geometric Transformations
rect_scaled = rect * 1.5 # Alternatively use CSGScaling(rect, 1.5)
rect_rot = CSGRotation(rect, numpy.pi/4)
rect_trans = CSGTranslation(rect, dolfin.Point(0.5, 0))

## Create dolfin::Mesh 
rect_mesh_scaled = generate_mesh(rect_scaled, 5)
rect_mesh_rot = generate_mesh(rect_rot, 5)
rect_mesh_trans = generate_mesh(rect_trans, 5)
```

![mesh2Dgeometric](../../assets/img/mshr2Dgeometric.png){: .center-image }

The API suggests that we can do more precise operations such as scaling or rotating about a point, but some of this functionality has only been implemented in the C code and has no Python wrapper (<a href="https://bitbucket.org/fenics-project/mshr/src/531b03a69566e94a3b9888632d5beb8070caac68/python/src/mshr.cpp?at=master&fileviewer=file-view-default">Source</a>). We can replicate this behaviour by chaining geometric transformations.

```python
## Scaling about a Point (0.5, 0.5)
rect_scaled = CSGTranslation(rect, dolfin.Point(-0.5, -0.5))
rect_scaled *= 1.5
rect_scaled = CSGTranslation(rect_scaled, dolfin.Point(0.5, 0.5))

## Rotation about a Point (0.5, 0.5)
rect_rot = CSGRotation(rect, dolfin.Point(0.5, 0.5), numpy.pi/4)

## Generate dolfin::Mesh
rect_mesh_scaled = generate_mesh(rect_scaled, 5)
rect_mesh_rot = generate_mesh(rect_rot, 5)

```

![mesh2Dgeom_point](../../assets/img/mshr2Dgeom_point.png){: .center-image }

---

## 3D MSHR

### Primitives
There are six 3D primitive shapes defined in mshr:
+ <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/Box">Box</a>
+ <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/Sphere">Sphere</a>
+ <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/Ellipsoid">Ellipsoid</a>
+ <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/Cone">Cone</a>
+ <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/Tetrahedron">Tetrahedron</a>
+ <a href="https://bitbucket.org/fenics-project/mshr/wiki/API/Cylinder">Cylinder</a>

```python
box = Box(dolfin.Point(0., 0., 0.), dolfin.Point(1., 1., 1.))
sphere = Sphere(dolfin.Point(0., 0., 0.), 0.5)
ellipsoid = Ellipsoid(dolfin.Point(0., 0., 0.), 0.8, 0.5, 0.5)
cone = Cone(dolfin.Point(0., 0., 0.), dolfin.Point(0., 0., 1.), 1.0)
tetra = Tetrahedron(dolfin.Point(0.5, 0.0, 0.), 
                    dolfin.Point(-0.5, 0, 0.5), 
                    dolfin.Point(-0.5, 0, -0.5), 
                    dolfin.Point(0., 1., 0.))
cylin = Cylinder(dolfin.Point(0., 0., 0.),
      		 dolfin.Point(0., 0., 1.), 0.5, 0.5)
```

This creates mshr::CSGPrimitive3d objects which can then be used to generate dolfin::Mesh objects.

```python
box_mesh = generate_mesh(box, 10)
sphere_mesh = generate_mesh(sphere, 10)
elllipsoid_mesh = generate_mesh(ellipsoid, 10)
cone_mesh = generate_mesh(cone, 10)
tetra_mesh = generate_mesh(tetra, 10)
cylin_mesh = generate_mesh(cylin, 10)
```
These meshes are plotted below:
```python
pyplot.figure()

ax = fig.add_subplot(2, 3, 1, projection='3d')
pyplot.title("Box")
plot(box_mesh)

ax = fig.add_subplot(2, 3, 2, projection='3d')
pyplot.title("Sphere")
plot(sphere_mesh)

ax = fig.add_subplot(2, 3, 3, projection='3d')
pyplot.title("Ellipsoid")
plot(ellipsoid_mesh)

ax = fig.add_subplot(2, 3, 4, projection='3d')
pyplot.title("Cone")
plot(cone_mesh)

ax = fig.add_subplot(2, 3, 5, projection='3d')
pyplot.title("Tetrahedron")
plot(tetra_mesh)

ax = fig.add_subplot(2, 3, 6, projection='3d')
pyplot.title("Cylinder")
plot(cylin_mesh)

pyplot.tight_layout();
```

![mshr3Dprimitives](../../assets/img/mshr3Dprimitives.png){: .center-image }

---

### Operations

#### Boolean

We will demonstrate boolean operations on a Box from $$(0, 0, 0)$$ to $$(1, 1, 1)$$ with a Sphere at $$(0, 0, 0)$$ with a radius, $$r = 0.5$$.

![mesh3Dbool_prim](../../assets/img/mshr3Dbool_prim.png){: .center-image }

Like the 2D version, the boolean operations are:
```python
diff_domain = box - sphere	  # Difference
union_domain = box + sphere	  # Union
intersect_domain = box * sphere   # Intersection

diff_mesh = generate_mesh(diff_domain, 10)
union_mesh = generate_mesh(union_domain, 10)
intersect_mesh = generate_mesh(intersect_domain, 10)
```

Plotting these gives us the following complex meshes: 
> NOTE: You can use %matplotlib notebook to view an interactive 3D plot in jupyter notebooks

![mesh3Dboolean](../../assets/img/mshr3Dboolean.png){: .center-image }

---

#### Geometric Transformations

---

## APPENDIX

Useful Links:
+ <a href="https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.generation.html">Dolfin Meshing Tools Documentation</a>
+ <a href="https://bitbucket.org/fenics-project/mshr/wiki/API">mshr API Reference</a>

Further Reading:

---
